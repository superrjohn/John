{
    "version": "https://jsonfeed.org/version/1",
    "title": "一切都是過程 • All posts by \"springsecurity\" tag",
    "description": "",
    "home_page_url": "https://superrjohn.github.io/John",
    "items": [
        {
            "id": "https://superrjohn.github.io/John/2023/10/30/java/SpringSecurity/SpringSecurity",
            "url": "https://superrjohn.github.io/John/2023/10/30/java/SpringSecurity/SpringSecurity",
            "title": "SpringSecurity 認證授權",
            "date_published": "2023-10-30T14:10:06.589Z",
            "content_html": "<p>在此特别感謝黑馬程序員提供的課程: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWo4NDExTjdCbS8=\">學成在線</span></p>\n<p>前言<br>\n於由實習項目快做完才做記錄，而且項目模塊較多，故挑部份來記錄，所以這遍主要是 SpringSecurity 內容。<br>\n<span class=\"rainbow\">完整项目地址</span>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N1cGVycmpvaG4vamF2YV93ZWI=\">https://github.com/superrjohn/java_web</span></p>\n<h1 id=\"模塊需求分析\"><a class=\"markdownIt-Anchor\" href=\"#模塊需求分析\">#</a> 模塊需求分析</h1>\n<p>什麼是認證授權？<br>\n<span class=\"yellow\"> 什麼是認證？</span></p>\n<blockquote><p>認證即使用者去存取系統資源時系統要求驗證使用者的身分訊息，身分合法方可繼續存取。 常見的用戶身份認證的表現形式有：用戶名密碼登錄，微信掃碼等方式。</p>\n</blockquote>\n<p><span class=\"yellow\">什麼是授權？</span></p>\n<blockquote><p>使用者認證通過後去存取系統的資源，系統會判斷使用者是否擁有存取資源的權限，只允許存取有權限的系統資源，沒有權限的資源將無法存取。</p>\n</blockquote>\n<h2 id=\"業務流程\"><a class=\"markdownIt-Anchor\" href=\"#業務流程\">#</a> 業務流程</h2>\n<p>1️⃣統一認證：計畫包括學生、學習機構的老師、平台營運人員三類用戶，三類用戶將使用統一的認證入口。</p>\n <img data-src=\"/John/img/java/SpringSecurity/2.png\" class=\"abc\" width=\"600\" height=\"350\">\n<p>2️⃣單點登陸：單一登入（Single Sign On），簡稱 SSO，是目前較流行的企業業務整合的解決方案之一。 SSO 的定義是在多個應用系統中，使用者只需要登入一次就可以存取所有互信的應用系統。</p>\n<p>3️⃣第三方認證：掃碼登入的功能，如：微信掃碼登入、QQ 掃碼登入等。 掃碼登入的好處是用戶不用輸入帳號和密碼，省去用戶註冊的成本，是一種非常有效的推廣手段。</p>\n<h1 id=\"spring-security-認證研究\"><a class=\"markdownIt-Anchor\" href=\"#spring-security-認證研究\">#</a> Spring Security 認證研究</h1>\n<h2 id=\"spring-security介紹\"><a class=\"markdownIt-Anchor\" href=\"#spring-security介紹\">#</a> Spring Security 介紹</h2>\n<p>認證功能幾乎是每個專案都要具備的功能，而且它與業務無關，市面上有許多認證框架，例如：Apache Shiro、CAS、Spring Security 等。 由於本專案是基於 Spring Cloud 技術構建，Spring Security 是 spring 家族的一份子且和 Spring Cloud 整合的很好，因此本專案選用 Spring Security 作為認證服務的技術框架。</p>\n<p>Spring Security 是一個功能強大且高度可自訂的身份驗證和存取控制框架，它是一個專注於為 Java 應用程式提供身份驗證和授權的框架。</p>\n<p>專案首頁：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLXNlY3VyaXR5\">https://spring.io/projects/spring-security</span></p>\n<p>Spring cloud Security： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWNsb3VkLXNlY3VyaXR5\">https://spring.io/projects/spring-cloud-security</span></p>\n<h3 id=\"認證授權入門\"><a class=\"markdownIt-Anchor\" href=\"#認證授權入門\">#</a> 認證授權入門</h3>\n<p>1️⃣部署認證服務工程</p>\n<p>從課程資料拷貝 xuecheng-plus-auth 工程到自己的工程目錄下。</p>\n<p>此工程是一個普通的 spring boot 工程，可以連接資料庫。</p>\n<p>此工程不具備認證授權的功能。</p>\n<p>2️⃣建立資料庫</p>\n<p>建立 xc_users 資料庫</p>\n<p>匯入課程資料中的 xcplus_users.sql 腳本。</p>\n<p>3️⃣修改配置文件和在 nacos 註冊，端口為 63070</p>\n<h3 id=\"認證測試\"><a class=\"markdownIt-Anchor\" href=\"#認證測試\">#</a> 認證測試</h3>\n<p>1️⃣下邊向 auth 認證工程整合 Spring security，向 pom.xml 加入 Spring Security 所需的依賴</p>\n<figure class=\"highlight xml\"><figcaption><span>pom.xml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-security<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>2️⃣初始工程自備了一個 Controller 類，如下：</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span> </span><br><span class=\"line\"><span class=\"meta\">@RestController</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginController</span> &#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span> </span><br><span class=\"line\">  XcUserMapper userMapper; </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"meta\">@RequestMapping(&quot;/login-success&quot;)</span> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">loginSuccess</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;登录成功&quot;</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"meta\">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> XcUser <span class=\"title function_\">getuser</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> String id)</span>&#123; </span><br><span class=\"line\">    <span class=\"type\">XcUser</span> <span class=\"variable\">xcUser</span> <span class=\"operator\">=</span> userMapper.selectById(id); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> xcUser; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"meta\">@RequestMapping(&quot;/r/r1&quot;)</span> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">r1</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;访问r1资源&quot;</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"meta\">@RequestMapping(&quot;/r/r2&quot;)</span> </span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">r2</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;访问r2资源&quot;</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>3️⃣在資料中找到 WebSecurityConfig 設定類放到本工程中，它繼承 WebSecurityConfigurerAdapter, 它有三部份內容:<br>\n1. 用戶資訊：在記憶體配置兩個使用者：zhangsan、lisi,zhangsan 使用者擁有的權限為 p1,lisi 使用者擁有的權限為 p2</p>\n<p>2、密碼方式：暫時採用明文方式</p>\n<p>3. 安全攔截機制:/r/** 開頭的請求需要認證，登入成功到成功頁面，程式碼如下：</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//配置用户信息服务 </span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> UserDetailsService <span class=\"title function_\">userDetailsService</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中 </span></span><br><span class=\"line\">    <span class=\"type\">InMemoryUserDetailsManager</span> <span class=\"variable\">manager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InMemoryUserDetailsManager</span>(); </span><br><span class=\"line\">        manager.createUser(User.withUsername(<span class=\"string\">&quot;zhangsan&quot;</span>).password(<span class=\"string\">&quot;123&quot;</span>).authorities(<span class=\"string\">&quot;p1&quot;</span>).build()); </span><br><span class=\"line\">        manager.createUser(User.withUsername(<span class=\"string\">&quot;lisi&quot;</span>).password(<span class=\"string\">&quot;456&quot;</span>).authorities(<span class=\"string\">&quot;p2&quot;</span>).build()); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> manager; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> PasswordEncoder <span class=\"title function_\">passwordEncoder</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//密码为明文方式 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> NoOpPasswordEncoder.getInstance(); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//配置安全拦截机制 </span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception &#123; </span><br><span class=\"line\">        http </span><br><span class=\"line\">                .authorizeRequests() </span><br><span class=\"line\">                .antMatchers(<span class=\"string\">&quot;/r/**&quot;</span>).authenticated()<span class=\"comment\">//访问/r开始的请求需要认证通过 </span></span><br><span class=\"line\">                .anyRequest().permitAll()<span class=\"comment\">//其它请求全部放行 </span></span><br><span class=\"line\">                .and() </span><br><span class=\"line\">                .formLogin().successForwardUrl(<span class=\"string\">&quot;/login-success&quot;</span>);<span class=\"comment\">//登录成功跳转到/login-success </span></span><br><span class=\"line\">                http.logout().logoutUrl(<span class=\"string\">&quot;/logout&quot;</span>);<span class=\"comment\">//退出地址 </span></span><br><span class=\"line\">    &#125; </span><br></pre></td></tr></table></figure>\n<p>1. 訪問 localhost:63070/auth/login<br>\n2. 輸入帳號 zhangsan, 密碼 123<br>\n3. 登錄成功後，頁面會跳轉，這樣認證身份就完成了</p>\n<p>4️⃣添加授權<br>\n🔴使用者認證透過去存取系統資源時 spring security 進行授權控制，判斷使用者是否有該資源的存取權限，如果有則繼續訪問，如果沒有則拒絕存取。<br>\n1. 在 WebSecurityConfig 類別設定 zhangsan 擁有 p1 權限，lisi 擁有 p2 權限。</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> UserDetailsService <span class=\"title function_\">userDetailsService</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">//这里配置用户信息,这里暂时使用这种方式将用户存储在内存中 </span></span><br><span class=\"line\">    <span class=\"type\">InMemoryUserDetailsManager</span> <span class=\"variable\">manager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InMemoryUserDetailsManager</span>(); </span><br><span class=\"line\">    manager.createUser(User.withUsername(<span class=\"string\">&quot;zhangsan&quot;</span>).password(<span class=\"string\">&quot;123&quot;</span>).authorities(<span class=\"string\">&quot;p1&quot;</span>).build()); </span><br><span class=\"line\">    manager.createUser(User.withUsername(<span class=\"string\">&quot;lisi&quot;</span>).password(<span class=\"string\">&quot;456&quot;</span>).authorities(<span class=\"string\">&quot;p2&quot;</span>).build()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> manager; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>2. 在 controller 中配置 /r/r1 需要 p1 權限，/r/r2 需要 p2 權限。</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginController</span> &#123; </span><br><span class=\"line\">    .... </span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/r/r1&quot;)</span> </span><br><span class=\"line\">    <span class=\"meta\">@PreAuthorize(&quot;hasAuthority(&#x27;p1&#x27;)&quot;)</span><span class=\"comment\">//拥有p1权限方可访问 </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">r1</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;访问r1资源&quot;</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/r/r2&quot;)</span> </span><br><span class=\"line\">    <span class=\"meta\">@PreAuthorize(&quot;hasAuthority(&#x27;p2&#x27;)&quot;)</span><span class=\"comment\">//拥有p2权限方可访问 </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">r2</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;访问r2资源&quot;</span>; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ... </span><br></pre></td></tr></table></figure>\n<p>現在當用戶訪問 /r/r1 時，url 會判斷用戶有沒有訪問權限 p1, 所以 zhangsan 可以成功訪問，而 lisi 不能，因為 lisi 的權限為 p2</p>\n<img data-src=\"/John/img/java/SpringSecurity/r1r2.png\" class=\"abc\">\n<p>5️⃣工作原理<br>\n Spring Security 對 Web 資源的保護是靠 Filter 實現的，所以從這個 Filter 來入手，逐步深入 Spring Security 原理。 當初始化 Spring Security 時，會建立一個名為 SpringSecurityFilterChain 的 Servlet 過濾器，類型為 org.springframework.security.web.FilterChainProxy，它實作了 javax.servlet.Filter，因此外部的要求會經過此類，下圖是 Spring Security 過慮器鏈結構圖：</p>\n<img data-src=\"/John/img/java/SpringSecurity/3.png\" class=\"abc\" width=\"400\" height=\"300\">\n<p>FilterChainProxy 是一個代理，真正運作的是 FilterChainProxy 中 SecurityFilterChain 所包含的各個 Filter，而 Filter 不會直接處理認證和授權，而是把它們交給了認證管理器（AuthenticationManager）和決策管理器（AccessDecisionManager）進行處理。</p>\n<h1 id=\"oauth2認證流程\"><a class=\"markdownIt-Anchor\" href=\"#oauth2認證流程\">#</a> OAuth2 認證流程</h1>\n<p>在前邊我們提到微信掃碼認證，這是一種第三方認證的方式，這種認證方式是基於 OAuth2 協定實現，</p>\n<p>OAUTH 協定為使用者資源的授權提供了一個安全的、開放而又簡易的標準。 同時，任何第三方都可以使用 OAUTH 認證服務，任何服務提供者都可以實現自身的 OAUTH 認證服務，因而 OAUTH 是開放的。 業界提供了 OAUTH 的多種實作如 PHP、JavaScript，Java，Ruby 等各種語言開發包，大大節省了程式設計師的時間，因而 OAUTH 是簡易的。 網路許多服務如 Open API，許多大公司如穀歌，Yahoo，Microsoft 等都提供了 OAUTH 認證服務，這些都足以說明 OAUTH 標準逐漸成為開放資源授權的標準。</p>\n<pre><code>     Oauth協定目前發展到2.0版本，1.0版本過於複雜，2.0版本已廣泛應用。\n</code></pre>\n<p>參考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9vQXV0aC83MTUzMTM0P2ZyPWFsYWRkaW4=\">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</span></p>\n<p>Oauth 協議：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDk=\">https://tools.ietf.org/html/rfc6749</span></p>\n<p>現在搞清楚幾個概念：</p>\n<p><span class=\"green\">資源</span>：使用者訊息，在微信中儲存。</p>\n<p><span class=\"green\">資源擁有者</span>：使用者是使用者資訊資源的擁有者。</p>\n<p><span class=\"green\">認證服務</span>：微信負責認證目前使用者的身份，負責為客戶端頒發令牌。</p>\n<p><span class=\"green\">客戶端</span>：客戶端會攜帶令牌請求微信獲取使用者訊息，黑馬程式設計師網站即客戶端，黑馬網站需要在瀏覽器中開啟。</p>\n<img data-src=\"/John/img/java/SpringSecurity/4.png\" class=\"abc\" width=\"700\" height=\"300\">\n<p>1. 用戶進入到網站打開掃碼界面，進行微信掃碼<br>\n 2. 微信返回信息，詢問用戶是否授權客戶端使用個人資料，用戶按同意<br>\n 3. 微信下發授權碼，網站應用帶著授權碼申請令牌，微信下發令牌 (過程不可見)<br>\n 4. 網站應用帶著令牌請求用戶個人信息，成功並返回網站應用 (過程不可見)<br>\n 5. 用戶登錄成功</p>\n<h2 id=\"oauth2在本項目的應用\"><a class=\"markdownIt-Anchor\" href=\"#oauth2在本項目的應用\">#</a> OAuth2 在本項目的應用</h2>\n<p>了解微信掃碼登入黑馬網站的流程，接下來認識 Oauth2.0 的認證流程，引自 Oauth2.0 協定 rfc6749 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDk=\">https://tools.ietf.org/html/rfc6749</span> ,<br>\nOauth2 是一個標準的開放的授權協議，用於應用程式需要用到第三方平台的資源，應用程式可以根據自己的要求去使用 Oauth2，本專案使用 Oauth2 實現以下目標：<br>\n1️⃣學成在線上存取第三方系統的資源。</p>\n<p>本專案要存取微信掃碼登入所以本專案要使用 OAuth2 協定存取微信中的使用者資訊。</p>\n<p>2️⃣外部系統訪問學成在線的資源 。</p>\n<p>同樣當第三方系統想要存取學成線上網站的資源也可以基於 OAuth2 協議。</p>\n<p>3️⃣學成線上前端（客戶端） 存取學成線上微服務的資源。</p>\n<p>本專案是前後端分離架構，前端存取微服務資源也可以基於 OAuth2 協定進行認證。</p>\n<h2 id=\"oauth2的授權模式\"><a class=\"markdownIt-Anchor\" href=\"#oauth2的授權模式\">#</a> OAuth2 的授權模式</h2>\n<p>Spring Security 支援 OAuth2 認證，OAuth2 提供授權碼模式、密碼模式、簡化模式、客戶端模式等四種授權模式，本項目只會用授權碼模式、密碼模式。<br>\n授權碼模式簡單瞭解是使用授權碼去取得令牌，要想取得令牌先要取得授權碼，授權碼的取得需要資源擁有者親自授權同意才可以取得。</p>\n<p>下圖是授權碼模式的互動圖：</p>\n<img data-src=\"/John/img/java/SpringSecurity/5.png\" class=\"abc\" width=\"600\" height=\"400\">\n<h3 id=\"授權碼模式測試\"><a class=\"markdownIt-Anchor\" href=\"#授權碼模式測試\">#</a> 授權碼模式測試</h3>\n<p>若要測試授權模式首先要設定授權伺服器即上圖中的認證伺服器，需要設定授權服務及令牌策略。<br>\n1️⃣從課程資料拷貝 AuthorizationServer.java、TokenConfig.java 到認證服務的 config 套件下。<br>\n說明：AuthorizationServer 用 @EnableAuthorizationServer 註解標識並繼承 AuthorizationServerConfigurerAdapter 來設定 OAuth2.0 授權伺服器。</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> </span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AuthorizationServer</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AuthorizationServerConfigurerAdapter</span> &#123; </span><br><span class=\"line\">... </span><br></pre></td></tr></table></figure>\n<p>2️⃣AuthorizationServerConfigurerAdapter 要求配置以下幾個類別：</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AuthorizationServerConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AuthorizationServerConfigurer</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AuthorizationServerConfigurerAdapter</span><span class=\"params\">()</span> &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">configure</span><span class=\"params\">(AuthorizationServerSecurityConfigurer security)</span> <span class=\"keyword\">throws</span> Exception &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span> <span class=\"keyword\">throws</span> Exception &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">configure</span><span class=\"params\">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class=\"keyword\">throws</span> Exception &#123;&#125; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>1）ClientDetailsServiceConfigurer：用來設定客戶端詳情服務（ClientDetailsService），</p>\n<p>隨便一個客戶端都可以隨便接取它的認證服務嗎？ 答案是否定的，服務提供者會給批准存取的客戶端一個身份，用於存取時的憑證，有客戶端標識和客戶端秘鑰，在這裡配置批准存取的客戶端的詳細資訊。</p>\n<p>2）AuthorizationServerEndpointsConfigurer：用來設定令牌（token）的存取端點和令牌服務 (token services)。</p>\n<p>3）AuthorizationServerSecurityConfigurer：用來設定令牌端點的安全性限制.</p>\n<p>2、TokenConfig 為令牌策略配置類</p>\n<p>暫時先使用 InMemoryTokenStore 在記憶體儲存令牌，令牌的有效期限等資訊配置如下：</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//令牌管理服务 </span></span><br><span class=\"line\"><span class=\"meta\">@Bean(name=&quot;authorizationServerTokenServicesCustom&quot;)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> AuthorizationServerTokenServices <span class=\"title function_\">tokenService</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    DefaultTokenServices service=<span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTokenServices</span>(); </span><br><span class=\"line\">    service.setSupportRefreshToken(<span class=\"literal\">true</span>);<span class=\"comment\">//支持刷新令牌 </span></span><br><span class=\"line\">    service.setTokenStore(tokenStore);<span class=\"comment\">//令牌存储策略 </span></span><br><span class=\"line\">    service.setAccessTokenValiditySeconds(<span class=\"number\">7200</span>); <span class=\"comment\">// 令牌默认有效期2小时 </span></span><br><span class=\"line\">    service.setRefreshTokenValiditySeconds(<span class=\"number\">259200</span>); <span class=\"comment\">// 刷新令牌默认有效期3天 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> service; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>3️⃣配置認證管理 bean</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span> </span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebSecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WebSecurityConfigurerAdapter</span> &#123; </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> AuthenticationManager <span class=\"title function_\">authenticationManagerBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.authenticationManagerBean(); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    .... </span><br></pre></td></tr></table></figure>\n<p>4️⃣重啟認證服務</p>\n<p>1.get 請求取得授權碼</p>\n<p>位址: <span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo2MzA3MC9hdXRoL29hdXRoL2F1dGhvcml6ZT9jbGllbnRfaWQ9WGNXZWJBcHAmYW1wO3Jlc3BvbnNlX3R5cGU9Y29kZSZhbXA7c2NvcGU9YWxsJmFtcDtyZWRpcmVjdF91cmk9aHR0cDovL3d3dy41MXh1ZWNoZW5nLmNu\">http://localhost:63070/auth/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.51xuecheng.cn</span></p>\n<p>參數列表如下：</p>\n<p>client_id：客戶端准入標識。</p>\n<p>response_type：授權碼模式固定為 code。</p>\n<p>scope：客戶端權限。</p>\n<p>redirect_uri：跳轉 uri，授權碼申請成功後會跳到此位址，後邊帶上 code 參數（授權碼）。</p>\n<p>輸入帳號 zhangsan、密碼 123 登入成功，輸入 /oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scope=all&amp;redirect_uri=<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy41MXh1ZWNoZW5nLmNu\">http://www.51xuecheng.cn</span></p>\n<p>顯示授權頁面</p>\n<img data-src=\"/John/img/java/SpringSecurity/6.png\" class=\"abc\">\n<p>授權「XcWebApp」存取自己的受保護資源？</p>\n<p>選擇同意。</p>\n<p>2. 請求成功，重新導向至<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy41MXh1ZWNoZW5nLmNuLz9jb2RlPSVFNiU4RSU4OCVFNiVBQyU4QSVFNyVBMiVCQyVFRiVCQyU4QyVFNCVCRSU4QiVFNSVBNiU4MiVFRiVCQyU5QWh0dHA6Ly93d3cuNTF4dWVjaGVuZy5jbi8/Y29kZT1XcWpiNUg=\"> http://www.51xuecheng.cn/?code = 授權碼，例如：http://www.51xuecheng.cn/?code=Wqjb5H</span><br>\n3. 使用 httpclient 工具 post 申請令牌</p>\n<p>/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=authorization_code&amp;code = 授權碼 &amp; redirect_uri=<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy41MXh1ZWNoZW5nLmNuLw==\">http://www.51xuecheng.cn/</span></p>\n<p>參數列表如下</p>\n<p>client_id：客戶端准入標識。</p>\n<p>client_secret：客戶端秘鑰。</p>\n<p>grant_type：授權類型，填入 authorization_code，表示授權碼模式</p>\n<p>code：授權碼，就是剛剛取得的授權碼，注意：授權碼只使用一次就無效了，需要重新申請。</p>\n<p>redirect_uri：申請授權碼時的跳到 url，一定和申請授權碼時用的 redirect_uri 一致。</p>\n<p>httpclient 腳本如下：</p>\n<figure class=\"highlight text\"><figcaption><span>text</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 第二步申请令牌 </span><br><span class=\"line\">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=authorization_code&amp;code=CTvCrB&amp;redirect_uri=http://www.51xuecheng.cn1</span><br></pre></td></tr></table></figure>\n<p>申請令牌成功如下所示：</p>\n<figure class=\"highlight json\"><figcaption><span>json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;access_token&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;368b1ee7-a9ee-4e9a-aae6-0fcab243aad2&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;token_type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bearer&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;refresh_token&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3d56e139-0ee6-4ace-8cbe-1311dfaa991f&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;expires_in&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">7199</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;scope&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;all&quot;</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span> </span><br></pre></td></tr></table></figure>\n<p>說明：<br>\n1、access_token，存取令牌，用於存取資源使用。<br>\n2、token_type，bearer 是在 RFC6750 中定義的一種 token 類型，在攜帶令牌存取資源時需要在 head 中加入 bearer 空格 令牌內容<br>\n 3、refresh_token，當令牌快過期時使用刷新令牌可以再次產生令牌。<br>\n4、expires_in：過期時間（秒）<br>\n5、scope，令牌的權限範圍，服務端可以根據令牌的權限範圍去對令牌授權。</p>\n<h3 id=\"密碼模式\"><a class=\"markdownIt-Anchor\" href=\"#密碼模式\">#</a> 密碼模式</h3>\n<p>密碼模式相對授權碼模式簡單，授權碼模式需使用瀏覽器供使用者親自授權，密碼模式不用使用瀏覽器<br>\n 1. 資源擁有者提供帳號及密碼</p>\n<p>2、客戶端向認證服務申請令牌，請求中攜帶帳號及密碼</p>\n<p>3、認證服務校驗帳號及密碼正確核發令牌。<br>\n1、POST 請求取得令牌</p>\n<p>/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=shangsan&amp;password=123</p>\n<p>參數列表如下：</p>\n<p>client_id：客戶端准入標識。</p>\n<p>client_secret：客戶端秘鑰。</p>\n<p>grant_type：授權類型，填入 password 表示密碼模式</p>\n<p>username：資源擁有者使用者名稱。</p>\n<p>password：資源擁有者密碼。</p>\n<p>2、授權伺服器將令牌（access_token）傳送給 client</p>\n<p>使用 httpclient 進行測試</p>\n<figure class=\"highlight java\"><figcaption><span>java</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 密码模式 </span><br><span class=\"line\">POST &#123;&#123;auth_host&#125;&#125;/auth/oauth/token?client_id=XcWebApp&amp;client_secret=XcWebApp&amp;grant_type=password&amp;username=zhangsan&amp;password=<span class=\"number\">123</span> </span><br></pre></td></tr></table></figure>\n<p>返回示例：</p>\n<figure class=\"highlight json\"><figcaption><span>json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;access_token&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;368b1ee7-a9ee-4e9a-aae6-0fcab243aad2&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;token_type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bearer&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;refresh_token&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3d56e139-0ee6-4ace-8cbe-1311dfaa991f&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;expires_in&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">6806</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;scope&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;all&quot;</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span> </span><br></pre></td></tr></table></figure>\n<h1 id=\"jwt令牌\"><a class=\"markdownIt-Anchor\" href=\"#jwt令牌\">#</a> JWT 令牌</h1>\n<h2 id=\"普通令牌的問題\"><a class=\"markdownIt-Anchor\" href=\"#普通令牌的問題\">#</a> 普通令牌的問題</h2>\n<p>客戶端申請到令牌，接下來客戶端攜帶令牌去存取資源，到資源伺服器將會校驗令牌的合法性。<br>\n資源伺服器如何校驗令牌的合法性？我們以 OAuth2 的密碼模式為例進行說明：</p>\n<img data-src=\"/John/img/java/SpringSecurity/7.png\" class=\"abc\" width=\"700\" height=\"400\">\n<p>🍉這裡存在一個問題：<br>\n就是校驗令牌需要遠端請求認證服務，客戶端的每次存取都會遠端校驗，執行效能低。<br>\n如果能夠讓資源服務自己校驗令牌的合法性將省去遠端請求認證服務的成本，提高了效能</p>\n<p>🍉如何解決上邊的問題，實現資源服務自行校驗令牌:</p>\n<h2 id=\"什么是jwt\"><a class=\"markdownIt-Anchor\" href=\"#什么是jwt\">#</a> 什么是 JWT</h2>\n<p>🟢令牌採用 JWT 格式即可解決上邊的問題，用戶認證通過後會得到一個 JWT 令牌，JWT 令牌中已經包括了用戶相關的信息，客戶端只需要攜帶 JWT 訪問資源服務，資源服務根據事先約定 的演算法自行完成令牌校驗，無需每次都請求認證服務完成授權。</p>\n<p>🟡JSON Web Token（JWT）是一種使用 JSON 格式傳遞資料的網路令牌技術，它是一個開放的行業標準（RFC 7519），它定義了一種簡潔的、自包含的協議格式，用於在通信 雙方傳遞 json 對象，傳遞的訊息經過數位簽章可以驗證和信任，它可以使用 HMAC 演算法或使用 RSA 的公鑰 / 私鑰對來簽名，防止內容篡改。 官網：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qd3QuaW8v\">https://jwt.io/</span></p>\n<p>🔴傳統的基於 session 的方式是有狀態認證，使用者登入成功將使用者的身份資訊儲存在服務端，這樣加大了服務端的儲存壓力，並且這種方式不適合在分散式系統中應用。<br>\n如下圖，當用戶訪問應用服務，每個應用服務都會去伺服器查看 session 信息，如果 session 中沒有該用戶則說明用戶沒有登錄，此時就會重新認證，而解決這個問題的方法是 Session 複製、Session 黏貼。</p>\n<img data-src=\"/John/img/java/SpringSecurity/8.png\" class=\"abc\" width=\"700\" height=\"400\">\n<p>🟢如果是基於令牌技術在分散式系統中實現認證則服務端不用儲存 session，可以將用戶識別資訊儲存在令牌中，用戶認證透過後認證服務頒發令牌給用戶，用戶將令牌儲存在客戶 端，去訪問應用服務時攜帶令牌去訪問，服務端從 jwt 解析出用戶資訊。 這個過程就是無狀態認證。</p>\n<p>JWT 令牌的優點：<br>\n1️⃣jwt 基於 json，非常方便解析。<br>\n2️⃣可以在令牌中自訂豐富的內容，易擴充。<br>\n3️⃣透過非對稱加密演算法及數位簽章技術，JWT 防止竄改，安全性高。<br>\n4️⃣資源服務使用 JWT 可不依賴認證服務即可完成授權。<br>\n缺點：<br>\nJWT 令牌較長，佔儲存空間比較大。</p>\n<p>JWT 令牌由三部分組成，每部分中間使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz<br>\n1️⃣Header<br>\n 頭部包括令牌的類型（即 JWT）及使用的哈希算法（如 HMAC SHA256 或 RSA）<br>\n内容使用 Base64Url 编码，得到一个字符串就是 JWT 令牌的第一部分。</p>\n  <figure class=\"highlight json\"><figcaption><span>json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;alg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;HS256&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;typ&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;JWT&quot;</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span> </span><br></pre></td></tr></table></figure>\n<p>2️⃣Payload<br>\n 第二部分是負載，內容也是一個 json 對象，它是存放有效資訊的地方，它可以存放 jwt 提供的資訊字段，例如：iss（簽發者）,exp（過期時間戳記）, sub（面向的使用者） 等，也可自訂欄位。<br>\n此部分不建議存放敏感訊息，因為此部分可以解碼還原原始內容。<br>\n最後將第二部分負載使用 Base64Url 編碼，得到一個字串就是 JWT 令牌的第二部分。</p>\n<figure class=\"highlight json\"><figcaption><span>json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;sub&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1234567890&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;456&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;admin&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span> </span><br></pre></td></tr></table></figure>\n<p>3️⃣Signature<br>\n 第三部分是簽名，此部分用於防止 jwt 內容被竄改。<br>\n這個部分使用 base64url 將前兩部分編碼，編碼後使用點（.）連接組成字串，最後使用 header 中聲明的簽章演算法進行簽章。</p>\n<figure class=\"highlight json\"><figcaption><span>json</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256( </span><br><span class=\"line\">  base64UrlEncode(header) + <span class=\"string\">&quot;.&quot;</span> + </span><br><span class=\"line\">  base64UrlEncode(payload)<span class=\"punctuation\">,</span> </span><br><span class=\"line\">  secret) </span><br></pre></td></tr></table></figure>\n<p><span class=\"green\">為什麼 JWT 可以防止篡改？</span></p>\n<blockquote><p>第三部分使用簽名演算法對第一部分和第二部分的內容進行簽名，常用的簽名演算法是 HS256，常見的還有 md5,sha 等，簽名演算法需要使用金鑰進行簽名，金鑰不對外公開，且 簽章是不可逆的，如果第三方更改了內容那麼伺服器驗證簽章就會失敗，要想保證驗證簽章正確必須保證內容、金鑰與簽章前一致。</p>\n</blockquote>\n",
            "tags": [
                "SpringSecurity"
            ]
        }
    ]
}